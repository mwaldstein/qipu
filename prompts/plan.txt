Create/update implementation plan using beads.

Source: `src/*`
Specs: `specs/*.md`
Goals: `README.md` (scope and non-goals)
Guidance: `docs/*` (non-spec examples)
Shared lib: `src/lib/*`
Issues: Use `bd` commands to manage tasks

## TRUST HIERARCHY

1. Code is truth. Specs/docs may be stale or wrong.
2. Tests prove behavior. Read test files to verify claims.
3. Existing plan may be inaccurate. Validate every "complete" item.

## AUDIT PROCESS

For each spec:
1. Read spec requirements
2. Search code for implementation (grep patterns, function names)
3. Check test coverage exists and passes
4. Compare actual behavior vs spec claims
5. Note gaps with file:line references

Before creating new issues, review deferred beads for readiness:
- Run `bd list --status deferred --limit 0` and decide if any should move to open (or stay deferred)
- If moving to open, update labels/priority so it shows up in `bd ready`

Use subagents in parallel - one per spec. Each must:
- Read the spec file
- Search src/ for implementation
- Search tests/ for coverage
- Report: implemented (with refs) | partial (what's missing) | not implemented

## WHAT TO LOOK FOR

- TODO/FIXME/unimplemented! in code
- #[ignore] or skip in tests
- Hardcoded/simulated behavior (scaffolds that don't do real work)
- Spec says X, code does Y (mismatches)
- Flag defined in CLI but handler is no-op
- Strategy/option not wired through
- Empty match arms or unreachable branches
- Panics/unwraps hiding incomplete error handling

## PRIORITY DEFINITIONS

- **P1: Correctness bugs** - Code exists but doesn't match spec behavior
- **P2: Missing test coverage** - Feature works but lacks tests
- **P3: Unimplemented but ready** - Spec is clear, implementation can proceed

## CATEGORIZATION

Every spec item must be in exactly one place:
1. **Code** - Implemented and tested
2. **Beads (P1-P2)** - Ready to implement (use `bd create`)
3. **Beads (P3, usually deferred, with blocked/design/draft/etc labels)** - Not implementation-ready

Items get P3 priority when:
- Spec marks as optional/future/v2
- Spec is ambiguous and needs clarification (label: design)
- Depends on unimplemented infrastructure (label: blocked)
- Requires design decisions not yet made (label: design)
- Open questions in spec not resolved (label: design)

Default handling for P3/non-ready items:
- Create/keep them as beads but set status `deferred` (so they don't appear in `bd ready`)
- Use labels like `design`, `clarify`, `draft`, `blocked`, `future`, `distribution`, `infra`
- When they become actionable, `bd undefer <id>` (or reopen) and adjust priority/labels

## OUTPUT

Create beads issues using `bd create`:
- Use `--priority 1` for P1 correctness bugs
- Use `--priority 2` for P2 test coverage gaps
- Use `--priority 3` for P3 future/design work
- Use `--label blocked` for items with dependencies
- Use `--label design` for items needing design work
- Include file:line refs in issue body
- Use `bd dep add <issue-id> --blocks <blocked-issue-id>` for dependencies

Use `bd defer <id>` (or `bd create --defer ...`) for P3 items that should not be worked now.

Update @specs/README.md status table:
- Spec/Impl/Tests columns with ✅/⚠️/❌
- Notes column for key gaps
- Update "Last audited" date

Run `bd sync` to save changes to git.

## RULES

- Plan only. No code changes.
- Never trust docs. Always verify in code.
- Never assume missing; confirm with code search first.
- Include file:line refs in issue bodies.
- Use `bd create` to track all gaps found during audit.
- Check existing issues with `bd list` before creating duplicates.
- If a needed feature has no spec, create specs/FILENAME.md first.
- Prefer shared utilities in `src/lib/` over ad-hoc implementations.
- Every spec requirement must be tracked: code or beads issue.
- Update issue priority/labels with `bd update` as readiness changes.
- Run `bd sync` after creating issues.

If no changes required: COMPLETE
