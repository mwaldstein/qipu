use super::ToolAdapter;
use crate::results::estimate_cost;
use crate::scenario::{Gate, Scenario};
use crate::session::SessionRunner;
use std::path::Path;

pub struct MockAdapter;

impl MockAdapter {
    fn generate_transcript(&self, scenario: &Scenario) -> String {
        let mut commands = Vec::new();

        for gate in &scenario.evaluation.gates {
            match gate {
                Gate::MinNotes { count } => {
                    for i in 0..*count {
                        commands.push(format!(
                            "qipu create --title 'Mock Note {}' --content 'Generated by mock adapter'",
                            i + 1
                        ));
                    }
                }
                Gate::NoteExists { id } => {
                    commands.push(format!(
                        "qipu create --id {} --title 'Note {}' --content 'Mock content'",
                        id, id
                    ));
                }
                Gate::LinkExists {
                    from,
                    to,
                    link_type,
                } => {
                    commands.push(format!(
                        "qipu link --from {} --to {} --type {}",
                        from, to, link_type
                    ));
                }
                Gate::SearchHit { query } => {
                    commands.push(format!(
                        "qipu create --title 'Search Result' --content 'This note contains: {}'",
                        query
                    ));
                }
                Gate::TagExists { tag } => {
                    commands.push(format!(
                        "qipu create --title 'Tagged Note' --tag {} --content 'Note with tag'",
                        tag
                    ));
                }
                Gate::ContentContains { id, substring } => {
                    commands.push(format!(
                        "qipu create --id {} --title 'Content Note' --content 'Note containing: {}'",
                        id, substring
                    ));
                }
                Gate::CommandSucceeds { command } => {
                    commands.push(format!("qipu {}", command));
                }
                Gate::MinLinks { .. } => {}
            }
        }

        if commands.is_empty() {
            commands.push("qipu list".to_string());
        }

        commands.join("\n")
    }
}

impl ToolAdapter for MockAdapter {
    fn check_availability(&self) -> anyhow::Result<()> {
        Ok(())
    }

    fn run(
        &self,
        scenario: &Scenario,
        cwd: &Path,
        model: Option<&str>,
        timeout_secs: u64,
    ) -> anyhow::Result<(String, i32, f64)> {
        let runner = SessionRunner::new();

        let transcript = self.generate_transcript(scenario);
        let mut full_output = String::new();

        let commands: Vec<&str> = transcript.lines().collect();
        let mut exit_code = 0;

        runner.run_command("qipu", &["init"], cwd, timeout_secs)?;

        for (i, command) in commands.iter().enumerate() {
            let parts: Vec<&str> = command.split_whitespace().collect();
            if parts.is_empty() || !parts[0].starts_with("qipu") {
                continue;
            }

            let cmd_name = parts[0];
            let args: Vec<String> = parts[1..].iter().map(|s| s.to_string()).collect();

            let (output, code) = runner.run_command(
                cmd_name,
                &args.iter().map(|s| s.as_str()).collect::<Vec<_>>(),
                cwd,
                timeout_secs,
            )?;

            if i > 0 {
                full_output.push_str("\n");
            }
            full_output.push_str(command);
            if !output.is_empty() {
                full_output.push_str("\n");
                full_output.push_str(&output);
            }

            if code != 0 && exit_code == 0 {
                exit_code = code;
            }
        }

        let input_chars = scenario.task.prompt.len();
        let output_chars = full_output.len();
        let model_name = model.unwrap_or("mock");
        let cost = estimate_cost(model_name, input_chars, output_chars);

        Ok((full_output, exit_code, cost))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_check_availability_always_succeeds() {
        let adapter = MockAdapter;
        assert!(adapter.check_availability().is_ok());
    }

    #[test]
    fn test_generate_transcript_min_notes() {
        let adapter = MockAdapter;
        let scenario_yaml = r#"
name: test
description: "Test"
fixture: qipu
task:
  prompt: "Test"
evaluation:
  gates:
    - type: min_notes
      count: 3
"#;
        let scenario: Scenario = serde_yaml::from_str(scenario_yaml).unwrap();
        let transcript = adapter.generate_transcript(&scenario);

        assert!(transcript.contains("qipu create"));
        assert!(transcript.lines().count() >= 3);
    }

    #[test]
    fn test_generate_transcript_note_exists() {
        let adapter = MockAdapter;
        let scenario_yaml = r#"
name: test
description: "Test"
fixture: qipu
task:
  prompt: "Test"
evaluation:
  gates:
    - type: note_exists
      id: "qp-1234"
"#;
        let scenario: Scenario = serde_yaml::from_str(scenario_yaml).unwrap();
        let transcript = adapter.generate_transcript(&scenario);

        assert!(transcript.contains("qp-1234"));
        assert!(transcript.contains("qipu create"));
    }

    #[test]
    fn test_generate_transcript_link_exists() {
        let adapter = MockAdapter;
        let scenario_yaml = r#"
name: test
description: "Test"
fixture: qipu
task:
  prompt: "Test"
evaluation:
  gates:
    - type: link_exists
      from: "qp-1234"
      to: "qp-5678"
      link_type: "related"
"#;
        let scenario: Scenario = serde_yaml::from_str(scenario_yaml).unwrap();
        let transcript = adapter.generate_transcript(&scenario);

        assert!(transcript.contains("qipu link"));
        assert!(transcript.contains("--from qp-1234"));
        assert!(transcript.contains("--to qp-5678"));
        assert!(transcript.contains("--type related"));
    }

    #[test]
    fn test_generate_transcript_search_hit() {
        let adapter = MockAdapter;
        let scenario_yaml = r#"
name: test
description: "Test"
fixture: qipu
task:
  prompt: "Test"
evaluation:
  gates:
    - type: search_hit
      query: "test query"
"#;
        let scenario: Scenario = serde_yaml::from_str(scenario_yaml).unwrap();
        let transcript = adapter.generate_transcript(&scenario);

        assert!(transcript.contains("qipu create"));
        assert!(transcript.contains("test query"));
    }

    #[test]
    fn test_generate_transcript_tag_exists() {
        let adapter = MockAdapter;
        let scenario_yaml = r#"
name: test
description: "Test"
fixture: qipu
task:
  prompt: "Test"
evaluation:
  gates:
    - type: tag_exists
      tag: "important"
"#;
        let scenario: Scenario = serde_yaml::from_str(scenario_yaml).unwrap();
        let transcript = adapter.generate_transcript(&scenario);

        assert!(transcript.contains("qipu create"));
        assert!(transcript.contains("--tag important"));
    }

    #[test]
    fn test_generate_transcript_content_contains() {
        let adapter = MockAdapter;
        let scenario_yaml = r#"
name: test
description: "Test"
fixture: qipu
task:
  prompt: "Test"
evaluation:
  gates:
    - type: content_contains
      id: "qp-1234"
      substring: "specific content"
"#;
        let scenario: Scenario = serde_yaml::from_str(scenario_yaml).unwrap();
        let transcript = adapter.generate_transcript(&scenario);

        assert!(transcript.contains("qp-1234"));
        assert!(transcript.contains("specific content"));
    }

    #[test]
    fn test_generate_transcript_command_succeeds() {
        let adapter = MockAdapter;
        let scenario_yaml = r#"
name: test
description: "Test"
fixture: qipu
task:
  prompt: "Test"
evaluation:
  gates:
    - type: command_succeeds
      command: "list"
"#;
        let scenario: Scenario = serde_yaml::from_str(scenario_yaml).unwrap();
        let transcript = adapter.generate_transcript(&scenario);

        assert!(transcript.contains("qipu list"));
    }

    #[test]
    fn test_generate_transcript_empty_gates() {
        let adapter = MockAdapter;
        let scenario_yaml = r#"
name: test
description: "Test"
fixture: qipu
task:
  prompt: "Test"
evaluation:
  gates: []
"#;
        let scenario: Scenario = serde_yaml::from_str(scenario_yaml).unwrap();
        let transcript = adapter.generate_transcript(&scenario);

        assert_eq!(transcript.trim(), "qipu list");
    }
}
