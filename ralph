#!/usr/bin/env bash
# ralph - Run ActAstra iteration loops
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
LOG_DIR="${LOG_DIR:-.ralph-logs}"
ITERATION=0
AUTO_COMMIT=true
MODE="vision-expand"
MAX_ITERATIONS=""
MODEL=""
PROMPT_FILE=""
DRY_RUN=false
CTRL_C_COUNT=0
STOP_AFTER_ITERATION=false

usage() {
    cat <<'EOF'
Usage: ralph [MODE] [OPTIONS]

MODE:
  vision-expand | expand    Iteratively expand vision (default)
  vision-reorg  | reorg     Reorganize/prune core docs
  plan                     Create/update implementation plan
  build                    Implement specs; build/test loop

OPTIONS:
  --max-iterations N        Maximum iterations before stopping
  --dry-run                 Print prompt + config, then exit
  --no-commit               Disable auto-commit
  --prompt-file FILE        Use a custom prompt file
  --log-dir DIR             Directory for iteration logs (default: .ralph-logs)
  -m, --model MODEL         Model to use
  -h, --help                Show this help message

ENVIRONMENT VARIABLES:
  MAX_ITERATIONS, LOG_DIR, MODEL
EOF
}

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

timestamp() {
    date +"%Y-%m-%dT%H:%M:%S%z"
}

log() {
    local ts
    ts="$(timestamp)"
    echo -e "${BLUE}[${ts}] [ralph] [${MODE}]${NC} $*"
}

log_success() {
    local ts
    ts="$(timestamp)"
    echo -e "${GREEN}[${ts}] [ralph] [${MODE}]${NC} $*"
}

log_warn() {
    local ts
    ts="$(timestamp)"
    echo -e "${YELLOW}[${ts}] [ralph] [${MODE}]${NC} $*"
}

log_error() {
    local ts
    ts="$(timestamp)"
    echo -e "${RED}[${ts}] [ralph] [${MODE}]${NC} $*" >&2
}

if [[ $# -gt 0 ]] && [[ "$1" != -* ]]; then
    MODE="$1"
    shift
fi

case "$MODE" in
    vision-expand|expand)
        MODE="vision-expand"
        MAX_ITERATIONS="${MAX_ITERATIONS:-50}"
        MODEL="${MODEL:-opencode/claude-opus-4-5}"
        PROMPT_FILE="${PROMPT_FILE:-$SCRIPT_DIR/prompts/vision-expansion.txt}"
        ;;
    vision-reorg|reorg)
        MODE="vision-reorg"
        MAX_ITERATIONS="${MAX_ITERATIONS:-5}"
        MODEL="${MODEL:-opencode/claude-sonnet-4-5}"
        PROMPT_FILE="${PROMPT_FILE:-$SCRIPT_DIR/prompts/vision-reorg.txt}"
        ;;
    plan)
        MODE="plan"
        MAX_ITERATIONS="${MAX_ITERATIONS:-5}"
        MODEL="${MODEL:-opencode/claude-opus-4-5}"
        PROMPT_FILE="${PROMPT_FILE:-$SCRIPT_DIR/prompts/plan.txt}"
        ;;
    build)
        MODE="build"
        MAX_ITERATIONS="${MAX_ITERATIONS:-200}"
        MODEL="${MODEL:-opencode/claude-opus-4-5}"
        PROMPT_FILE="${PROMPT_FILE:-$SCRIPT_DIR/prompts/build.txt}"
        ;;
    *)
        echo "Unknown mode: $MODE" >&2
        usage >&2
        exit 1
        ;;
esac

while [[ $# -gt 0 ]]; do
    case "$1" in
        --max-iterations)
            MAX_ITERATIONS="$2"
            shift 2
            ;;
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        --no-commit)
            AUTO_COMMIT=false
            shift
            ;;
        --prompt-file)
            PROMPT_FILE="$2"
            shift 2
            ;;
        --log-dir)
            LOG_DIR="$2"
            shift 2
            ;;
        -m|--model)
            MODEL="$2"
            shift 2
            ;;
        -h|--help)
            usage
            exit 0
            ;;
        *)
            log_error "Unknown option: $1"
            usage >&2
            exit 1
            ;;
    esac
done

if [[ ! -f "$PROMPT_FILE" ]]; then
    log_error "Prompt file not found: $PROMPT_FILE"
    exit 1
fi
PROMPT_LABEL="$(basename "$PROMPT_FILE")"
PROMPT_CONTENT="$(cat "$PROMPT_FILE")"

if ! command -v opencode >/dev/null 2>&1; then
    log_error "opencode command not found. Please install opencode first."
    exit 1
fi

OPENCODE_CMD=(opencode run)
if [[ -n "$MODEL" ]]; then
    OPENCODE_CMD+=( -m "$MODEL" )
fi

if [[ "$DRY_RUN" == "true" ]]; then
    log "Dry run mode"
    log "Mode: $MODE"
    log "Max iterations: $MAX_ITERATIONS"
    [[ -n "$MODEL" ]] && log "Model: $MODEL"
    log "Prompt: $PROMPT_LABEL"
    [[ "$AUTO_COMMIT" == "true" ]] && log "Auto-commit: enabled" || log "Auto-commit: disabled"
    log "Command: ${OPENCODE_CMD[*]} '<prompt>'"
    echo ""
    echo "---"
    echo "$PROMPT_CONTENT"
    echo "---"
    exit 0
fi

mkdir -p "$LOG_DIR"

IN_GIT_REPO=false
REPO_ROOT=""
if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    IN_GIT_REPO=true
    REPO_ROOT="$(git rev-parse --show-toplevel)"
fi

LOG_DIR_GIT_PATH=""
if [[ "$IN_GIT_REPO" == "true" ]]; then
    LOG_DIR_ABS="$(cd "$LOG_DIR" && pwd)"
    if [[ "$LOG_DIR_ABS" == "$REPO_ROOT"/* ]]; then
        LOG_DIR_GIT_PATH="${LOG_DIR_ABS#$REPO_ROOT/}"
    fi
fi

if [[ "$AUTO_COMMIT" == "true" ]]; then
    if [[ "$IN_GIT_REPO" != "true" ]]; then
        log_error "Auto-commit enabled but not in a git repository. Re-run with --no-commit."
        exit 1
    fi

    if ! git -C "$REPO_ROOT" config user.name >/dev/null 2>&1 || ! git -C "$REPO_ROOT" config user.email >/dev/null 2>&1; then
        log_error "Git user.name/user.email not configured. Configure git or re-run with --no-commit."
        exit 1
    fi

    if [[ -n "$(git -C "$REPO_ROOT" status --porcelain)" ]]; then
        log_error "Working tree is not clean. Commit/stash changes or re-run with --no-commit."
        exit 1
    fi
fi

auto_commit_iteration() {
    local iteration="$1"

    if [[ "$AUTO_COMMIT" != "true" ]]; then
        return 0
    fi

    local msg="ralph [${MODE}]: iteration ${iteration} (${PROMPT_LABEL}${MODEL:+; model=${MODEL}})"

    git -C "$REPO_ROOT" add -A
    if [[ -n "$LOG_DIR_GIT_PATH" ]]; then
        git -C "$REPO_ROOT" reset --quiet -- "$LOG_DIR_GIT_PATH" || true
    fi

    if git -C "$REPO_ROOT" diff --cached --quiet; then
        return 0
    fi

    if ! git -C "$REPO_ROOT" commit -m "$msg"; then
        log_error "git commit failed; aborting loop"
        return 1
    fi

    log_success "Committed changes: $msg"
}

working_tree_changed() {
    if [[ "$IN_GIT_REPO" != "true" ]]; then
        echo "unknown"
        return 0
    fi

    if [[ -n "$(git -C "$REPO_ROOT" status --porcelain)" ]]; then
        echo "true"
        return 0
    fi

    echo "false"
}

# Signal handler for Ctrl-C
handle_ctrl_c() {
    log "DEBUG: handle_ctrl_c called, CTRL_C_COUNT=$CTRL_C_COUNT"
    CTRL_C_COUNT=$((CTRL_C_COUNT + 1))
    if [[ $CTRL_C_COUNT -eq 1 ]]; then
        log_warn "Ctrl-C pressed - will stop after this iteration (press again to stop immediately)"
        STOP_AFTER_ITERATION=true
        log "DEBUG: Set STOP_AFTER_ITERATION=true"
    elif [[ $CTRL_C_COUNT -eq 2 ]]; then
        log_warn "Ctrl-C pressed again - stopping immediately"
        exit 130
    fi
}

# Set up signal handler
trap handle_ctrl_c INT

log "Starting loop"
log "Max iterations: $MAX_ITERATIONS"
log "Prompt: $PROMPT_LABEL"
log "Logs will be saved to: $LOG_DIR"
[[ -n "$MODEL" ]] && log "Model: $MODEL"
[[ "$AUTO_COMMIT" == "true" ]] && log "Auto-commit: enabled" || log "Auto-commit: disabled"

while [[ $ITERATION -lt $MAX_ITERATIONS ]]; do
    log "DEBUG: Starting iteration $ITERATION loop, STOP_AFTER_ITERATION=$STOP_AFTER_ITERATION"
    ITERATION=$((ITERATION + 1))
    TIMESTAMP="$(date +%Y%m%d_%H%M%S)"
    LOG_FILE="$LOG_DIR/${MODE}_iteration_${ITERATION}_${TIMESTAMP}.log"

    log "--- Iteration $ITERATION of $MAX_ITERATIONS ---"
    log "DEBUG: About to start opencode execution"

    TEMP_OUTPUT="$(mktemp)"
    
    log "DEBUG: About to run opencode, STOP_AFTER_ITERATION=$STOP_AFTER_ITERATION"
    
    # Create a wrapper script that blocks signals and runs opencode
    # This provides complete isolation from Ctrl-C
    WRAPPER_SCRIPT=$(mktemp)
    cat > "$WRAPPER_SCRIPT" << 'WRAPPER_EOF'
#!/bin/bash
# Block all termination signals
trap '' INT TERM QUIT
# Execute opencode
exec "$@"
WRAPPER_EOF
    chmod +x "$WRAPPER_SCRIPT"
    
    log "DEBUG: Starting opencode with wrapper"
    
    # Run opencode with the signal-blocking wrapper
    # Use set +e temporarily to prevent set -e from exiting on SIGINT
    set +e
    "$WRAPPER_SCRIPT" "${OPENCODE_CMD[@]}" "$PROMPT_CONTENT" 2>&1 | tee "$TEMP_OUTPUT"
    EXIT_CODE=${PIPESTATUS[0]}
    set -e
    
    log "DEBUG: opencode exited with code $EXIT_CODE"
    
    rm -f "$WRAPPER_SCRIPT"
    
    if [[ $EXIT_CODE -eq 0 ]]; then

        HAS_CHANGES="$(working_tree_changed)"
        log "DEBUG: HAS_CHANGES=$HAS_CHANGES"

        auto_commit_iteration "$ITERATION"

        log "DEBUG: Checking for COMPLETE marker"
        if grep -q "^COMPLETE$" "$TEMP_OUTPUT"; then
            log "DEBUG: COMPLETE marker found"
            if [[ "$HAS_CHANGES" == "false" ]]; then
                log_success "COMPLETE detected"
                rm -f "$TEMP_OUTPUT"
                exit 0
            fi

            if [[ "$HAS_CHANGES" == "unknown" ]]; then
                log_warn "COMPLETE detected but change detection unavailable; stopping"
                rm -f "$TEMP_OUTPUT"
                exit 0
            fi

            log_warn "COMPLETE detected but changes were made - continuing"
        else
            log "DEBUG: No COMPLETE marker found"
        fi
    else
        # If opencode exited with non-zero code
        if [[ $EXIT_CODE -eq 130 && "$STOP_AFTER_ITERATION" == "true" ]]; then
            # This is expected behavior when Ctrl-C was pressed during execution
            log "opencode completed after Ctrl-C request"
        else
            log_warn "opencode failed (exit $EXIT_CODE); continuing"
        fi
        cp "$TEMP_OUTPUT" "$LOG_FILE" || true
    fi

    rm -f "$TEMP_OUTPUT"
    
    log "DEBUG: End of iteration $ITERATION, checking STOP_AFTER_ITERATION=$STOP_AFTER_ITERATION"
    
    # Check if we should stop after this iteration
    if [[ "$STOP_AFTER_ITERATION" == "true" ]]; then
        log_warn "Stopping after iteration $ITERATION as requested"
        # Reset any interrupted state before exiting
        trap - INT
        exit 0
    fi
    
    sleep 2
    log "DEBUG: Completed iteration $ITERATION, continuing to next"
done

log_warn "Maximum iterations ($MAX_ITERATIONS) reached"
exit 2
